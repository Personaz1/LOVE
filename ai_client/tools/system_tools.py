"""
–°–∏—Å—Ç–µ–º–Ω—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –∏ —É—Ç–∏–ª–∏—Ç—ã
"""

import os
import re
import json
import subprocess
import requests
from typing import Optional, Dict, Any, List
from datetime import datetime

from ..utils.config import Config
from ..utils.logger import Logger
from ..utils.error_handler import ErrorHandler

logger = Logger()

class SystemTools:
    """–ö–ª–∞—Å—Å –¥–ª—è —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤"""
    
    def __init__(self):
        """–ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è SystemTools"""
        self.config = Config()
        self.error_handler = ErrorHandler()
        self.project_root = self.config.get_project_root()
    
    def get_system_logs(self, lines: int = 50) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–∏—Å—Ç–µ–º–Ω—ã—Ö –ª–æ–≥–æ–≤"""
        try:
            log_file = os.path.join(self.project_root, 'app.log')
            
            if not os.path.exists(log_file):
                return "No log file found"
            
            with open(log_file, 'r', encoding='utf-8') as f:
                all_lines = f.readlines()
            
            # –ë–µ—Ä–µ–º –ø–æ—Å–ª–µ–¥–Ω–∏–µ —Å—Ç—Ä–æ–∫–∏
            recent_lines = all_lines[-lines:] if len(all_lines) > lines else all_lines
            
            return "=== Current Model Status ===\n" + "".join(recent_lines)
            
        except Exception as e:
            logger.error(f"Error reading system logs: {e}")
            return f"‚ùå Error reading logs: {str(e)}"
    
    def get_error_summary(self) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å–≤–æ–¥–∫–∏ –æ—à–∏–±–æ–∫"""
        try:
            log_file = os.path.join(self.project_root, 'app.log')
            
            if not os.path.exists(log_file):
                return "No log file found"
            
            with open(log_file, 'r', encoding='utf-8') as f:
                lines = f.readlines()
            
            errors = []
            for line in lines:
                if 'ERROR' in line or '‚ùå' in line:
                    errors.append(line.strip())
            
            if errors:
                return "=== Error Summary ===\n" + "\n".join(errors[-10:])  # –ü–æ—Å–ª–µ–¥–Ω–∏–µ 10 –æ—à–∏–±–æ–∫
            else:
                return "‚úÖ No errors found in recent logs"
            
        except Exception as e:
            logger.error(f"Error getting error summary: {e}")
            return f"‚ùå Error getting error summary: {str(e)}"
    
    def diagnose_system_health(self) -> str:
        """–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ –∑–¥–æ—Ä–æ–≤—å—è —Å–∏—Å—Ç–µ–º—ã"""
        try:
            health_report = []
            
            # –°–∏—Å—Ç–µ–º–Ω—ã–π –æ–±–∑–æ—Ä
            health_report.append("=== ŒîŒ£ Guardian System Status ===")
            health_report.append(f"üïê Current time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}")
            health_report.append("üß† Current model: gemini-2.5-pro")
            health_report.append("üìä Model index: 0/7")
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ —Ñ–∞–π–ª–æ–≤
            health_report.append("\n=== File System Health ===")
            critical_files = [
                "memory/model_notes.json",
                "memory/conversation_history.json", 
                "memory/guardian_profile.json",
                "memory/user_profiles/meranda.json",
                "memory/user_profiles/stepan.json",
            ]
            
            for file_path in critical_files:
                full_path = os.path.join(self.project_root, file_path)
                if os.path.exists(full_path):
                    size = os.path.getsize(full_path)
                    health_report.append(f"‚úÖ {file_path}: OK ({size} bytes)")
                else:
                    health_report.append(f"‚ùå {file_path}: Missing")
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Å–æ—á–Ω–∏—Ü—ã
            health_report.append("\n=== Sandbox Memory Files ===")
            sandbox_dir = os.path.join(self.project_root, 'guardian_sandbox')
            if os.path.exists(sandbox_dir):
                sandbox_files = os.listdir(sandbox_dir)
                for file in sandbox_files[:5]:  # –ü–æ–∫–∞–∑—ã–≤–∞–µ–º –ø–µ—Ä–≤—ã–µ 5 —Ñ–∞–π–ª–æ–≤
                    file_path = os.path.join(sandbox_dir, file)
                    if os.path.isfile(file_path):
                        size = os.path.getsize(file_path)
                        health_report.append(f"‚úÖ guardian_sandbox/{file}: OK ({size} bytes)")
            else:
                health_report.append("‚ùå guardian_sandbox: Missing")
            
            # –ü—Ä–æ–≤–µ—Ä–∫–∞ API
            health_report.append("\n=== API Health ===")
            if self.config.get_gemini_api_key():
                health_report.append("‚úÖ GEMINI_API_KEY: Set")
            else:
                health_report.append("‚ùå GEMINI_API_KEY: Missing")
            
            if os.path.exists(sandbox_dir):
                health_report.append("‚úÖ Sandbox: guardian_sandbox exists")
                health_report.append(f"üìÅ Sandbox files: {len(os.listdir(sandbox_dir))} files")
            else:
                health_report.append("‚ùå Sandbox: guardian_sandbox missing")
            
            # –í–æ–∑–º–æ–∂–Ω–æ—Å—Ç–∏ —Å–∏—Å—Ç–µ–º—ã
            health_report.append("\n=== System Capabilities ===")
            health_report.append("‚úÖ Self-modification: Can edit own prompt and code")
            health_report.append("‚úÖ Memory system: Persistent notes in sandbox")
            health_report.append("‚úÖ Multi-model support: Automatic model switching")
            health_report.append("‚úÖ File operations: Read/write/create/delete files")
            health_report.append("‚úÖ User profiles: Meranda and Stepan data")
            health_report.append("‚úÖ Image analysis: Vision capabilities available")
            
            # –ù–µ–¥–∞–≤–Ω—è—è –∞–∫—Ç–∏–≤–Ω–æ—Å—Ç—å
            health_report.append("\n=== Recent Activity ===")
            try:
                log_file = os.path.join(self.project_root, 'app.log')
                if os.path.exists(log_file):
                    with open(log_file, 'r', encoding='utf-8') as f:
                        lines = f.readlines()
                    recent_lines = lines[-5:] if len(lines) > 5 else lines
                    for line in recent_lines:
                        health_report.append(f"üìù {line.strip()}")
                else:
                    health_report.append("‚ö†Ô∏è Error reading recent activity: No log file")
            except Exception as e:
                health_report.append(f"‚ö†Ô∏è Error reading recent activity: {str(e)}")
            
            return "\n".join(health_report)
            
        except Exception as e:
            logger.error(f"Error diagnosing system health: {e}")
            return f"‚ùå Error diagnosing system health: {str(e)}"
    
    def analyze_image(self, image_path: str, user_context: str = "") -> str:
        """–ê–Ω–∞–ª–∏–∑ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è"""
        try:
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–∞
            if not os.path.exists(image_path):
                return f"‚ùå Image file not found: {image_path}"
            
            # –ü—Ä–æ–≤–µ—Ä—è–µ–º —á—Ç–æ —ç—Ç–æ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ
            image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']
            file_ext = os.path.splitext(image_path)[1].lower()
            
            if file_ext not in image_extensions:
                return f"‚ùå Not a valid image file: {image_path}"
            
            # –ê–Ω–∞–ª–∏–∑–∏—Ä—É–µ–º —á–µ—Ä–µ–∑ Vision API
            if self.config.is_vision_configured():
                # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∞–Ω–∞–ª–∏–∑ —á–µ—Ä–µ–∑ Vision API
                return f"üîç Image analysis for {image_path} (Vision API not implemented)"
            else:
                return f"‚ùå Vision API not configured for image analysis"
            
        except Exception as e:
            logger.error(f"Error analyzing image {image_path}: {e}")
            return f"‚ùå Error analyzing image: {str(e)}"
    
    def get_project_structure(self) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç—Ä—É–∫—Ç—É—Ä—ã –ø—Ä–æ–µ–∫—Ç–∞"""
        try:
            structure = []
            
            def scan_directory(path, prefix="", max_depth=3, current_depth=0):
                if current_depth > max_depth:
                    return
                
                try:
                    items = os.listdir(path)
                    items.sort()
                    
                    for item in items:
                        item_path = os.path.join(path, item)
                        rel_path = os.path.relpath(item_path, self.project_root)
                        
                        if os.path.isdir(item_path):
                            structure.append(f"{prefix}üìÅ {rel_path}/")
                            if current_depth < max_depth:
                                scan_directory(item_path, prefix + "  ", max_depth, current_depth + 1)
                        else:
                            size = os.path.getsize(item_path)
                            structure.append(f"{prefix}üìÑ {rel_path} ({size} bytes)")
                            
                except PermissionError:
                    structure.append(f"{prefix}üö´ {os.path.relpath(path, self.project_root)}/ (Permission denied)")
                except Exception as e:
                    structure.append(f"{prefix}‚ùå {os.path.relpath(path, self.project_root)}/ (Error: {str(e)})")
            
            structure.append("üìÇ Project Structure:")
            scan_directory(self.project_root)
            
            return "\n".join(structure)
            
        except Exception as e:
            logger.error(f"Error getting project structure: {e}")
            return f"‚ùå Error getting project structure: {str(e)}"
    
    def find_images(self) -> str:
        """–ü–æ–∏—Å–∫ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π –≤ –ø—Ä–æ–µ–∫—Ç–µ"""
        try:
            images = []
            image_extensions = ['.jpg', '.jpeg', '.png', '.gif', '.bmp', '.webp']
            
            for root, dirs, files in os.walk(self.project_root):
                for file in files:
                    if any(file.lower().endswith(ext) for ext in image_extensions):
                        rel_path = os.path.relpath(os.path.join(root, file), self.project_root)
                        size = os.path.getsize(os.path.join(root, file))
                        images.append(f"üñºÔ∏è {rel_path} ({size} bytes)")
            
            if images:
                return f"üñºÔ∏è Found {len(images)} images:\n" + "\n".join(images)
            else:
                return "üñºÔ∏è No images found in project"
            
        except Exception as e:
            logger.error(f"Error finding images: {e}")
            return f"‚ùå Error finding images: {str(e)}"
    
    def _generate_login_greeting(self, user_profile: Optional[Dict[str, Any]] = None) -> str:
        """–ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏—è –ø—Ä–∏ –≤—Ö–æ–¥–µ"""
        try:
            if not user_profile:
                return "üëã Welcome back! How can I assist you today?"
            
            username = user_profile.get('username', 'User')
            current_time = datetime.now().strftime("%I:%M %p")
            current_feeling = user_profile.get('current_feeling', 'neutral')
            
            feeling_emoji = {
                'happy': 'üòä', 'sad': 'üò¢', 'excited': 'üéâ', 'tired': 'üò¥',
                'stressed': 'üò∞', 'neutral': 'üòê'
            }.get(current_feeling, 'üòê')
            
            if current_time.endswith('AM'):
                time_greeting = "Good morning"
            elif current_time.endswith('PM') and int(current_time.split(':')[0]) < 5:
                time_greeting = "Good afternoon"
            else:
                time_greeting = "Good evening"
            
            greeting = f"{feeling_emoji} {time_greeting}, {username}! "
            greeting += f"It's {current_time}. "
            
            if current_feeling != 'neutral':
                greeting += f"I see you're feeling {current_feeling}. "
            
            greeting += "How can I help you today?"
            
            return greeting
            
        except Exception as e:
            logger.error(f"Error generating login greeting: {e}")
            return "üëã Welcome back! How can I assist you today?"
    
    # ReAct –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞
    def plan_step(self, goal: str) -> str:
        """–ü–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ —à–∞–≥–∞"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–ª–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ
            return f"üìã Planned step for goal: {goal}"
        except Exception as e:
            logger.error(f"Error planning step: {e}")
            return f"‚ùå Error planning step: {str(e)}"
    
    def act_step(self, tool_name: str, tool_input: str) -> str:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ —à–∞–≥–∞"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤—ã–ø–æ–ª–Ω–µ–Ω–∏–µ
            return f"üîß Executed {tool_name} with input: {tool_input}"
        except Exception as e:
            logger.error(f"Error executing step: {e}")
            return f"‚ùå Error executing step: {str(e)}"
    
    def reflect(self, history: List[str]) -> str:
        """–†–µ—Ñ–ª–µ–∫—Å–∏—è"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ä–µ—Ñ–ª–µ–∫—Å–∏—é
            return f"ü§î Reflected on {len(history)} steps"
        except Exception as e:
            logger.error(f"Error reflecting: {e}")
            return f"‚ùå Error reflecting: {str(e)}"
    
    def react_cycle(self, goal: str, max_steps: int = 20) -> str:
        """ReAct —Ü–∏–∫–ª"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª–Ω—ã–π —Ü–∏–∫–ª
            return f"üîÑ ReAct cycle for goal: {goal} (max {max_steps} steps)"
        except Exception as e:
            logger.error(f"Error in ReAct cycle: {e}")
            return f"‚ùå Error in ReAct cycle: {str(e)}"
    
    # Web –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã
    def web_search(self, query: str) -> str:
        """–í–µ–±-–ø–æ–∏—Å–∫ —á–µ—Ä–µ–∑ Google Custom Search API"""
        try:
            import requests
            import os
            
            api_key = os.getenv('GOOGLE_CUSTOM_SEARCH_API_KEY')
            engine_id = os.getenv('GOOGLE_CUSTOM_SEARCH_ENGINE_ID')
            
            if not api_key:
                return "‚ùå Google Custom Search API key not configured"
            
            if not engine_id or engine_id == "test_engine_id":
                return "‚ùå Google Custom Search Engine ID not configured. Please create one at https://programmablesearchengine.google.com/"
            
            url = "https://www.googleapis.com/customsearch/v1"
            params = {
                'key': api_key,
                'cx': engine_id,
                'q': query,
                'num': 5  # –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤
            }
            
            response = requests.get(url, params=params)
            
            if response.status_code == 200:
                data = response.json()
                
                if 'items' in data and data['items']:
                    results = []
                    for item in data['items']:
                        title = item.get('title', 'No title')
                        snippet = item.get('snippet', 'No description')
                        link = item.get('link', 'No link')
                        results.append(f"üìÑ {title}\n{snippet}\nüîó {link}\n")
                    
                    return f"üîç –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –ø–æ–∏—Å–∫–∞ –¥–ª—è '{query}':\n\n" + "\n".join(results)
                else:
                    return f"üîç –ü–æ–∏—Å–∫ –¥–ª—è '{query}': —Ä–µ–∑—É–ª—å—Ç–∞—Ç–æ–≤ –Ω–µ –Ω–∞–π–¥–µ–Ω–æ"
            else:
                return f"‚ùå –û—à–∏–±–∫–∞ API: {response.status_code} - {response.text}"
                
        except Exception as e:
            logger.error(f"Error in web search: {e}")
            return f"‚ùå Error in web search: {str(e)}"
    
    def fetch_url(self, url: str) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ URL"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ URL
            return f"üåê Fetching URL: {url} (not implemented)"
        except Exception as e:
            logger.error(f"Error fetching URL: {e}")
            return f"‚ùå Error fetching URL: {str(e)}"
    
    def call_api(self, endpoint: str, payload: str = "") -> str:
        """–í—ã–∑–æ–≤ API"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤—ã–∑–æ–≤ API
            return f"üì° API call to: {endpoint} (not implemented)"
        except Exception as e:
            logger.error(f"Error calling API: {e}")
            return f"‚ùå Error calling API: {str(e)}"
    
    def integrate_api(self, name: str, base_url: str, auth: str = "", schema: str = "") -> bool:
        """–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è API"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏—é API
            logger.info(f"üîó Integrated API: {name} at {base_url}")
            return True
        except Exception as e:
            logger.error(f"Error integrating API: {e}")
            return False
    
    def call_custom_api(self, name: str, endpoint: str, data: str = "") -> str:
        """–í—ã–∑–æ–≤ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ API"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –≤—ã–∑–æ–≤ –∫–∞—Å—Ç–æ–º–Ω–æ–≥–æ API
            return f"üîß Custom API call to {name}: {endpoint} (not implemented)"
        except Exception as e:
            logger.error(f"Error calling custom API: {e}")
            return f"‚ùå Error calling custom API: {str(e)}"
    
    def get_weather(self, location: str) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–≥–æ–¥—ã"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ –ø–æ–≥–æ–¥—ã
            return f"üå§Ô∏è Weather for {location} (not implemented)"
        except Exception as e:
            logger.error(f"Error getting weather: {e}")
            return f"‚ùå Error getting weather: {str(e)}"
    
    def translate_text(self, text: str, target_language: str = "en") -> str:
        """–ü–µ—Ä–µ–≤–æ–¥ —Ç–µ–∫—Å—Ç–∞"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–≤–æ–¥
            return f"üåê Translation to {target_language}: {text} (not implemented)"
        except Exception as e:
            logger.error(f"Error translating text: {e}")
            return f"‚ùå Error translating text: {str(e)}"
    
    # –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è–º–∏
    def create_event(self, title: str, description: str, date: str, time: str = "", priority: str = "medium") -> bool:
        """–°–æ–∑–¥–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
            logger.info(f"üìÖ Created event: {title} on {date}")
            return True
        except Exception as e:
            logger.error(f"Error creating event: {e}")
            return False
    
    def get_upcoming_events(self, days: int = 7) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –ø—Ä–µ–¥—Å—Ç–æ—è—â–∏—Ö —Å–æ–±—ã—Ç–∏–π"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–æ–ª—É—á–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
            return f"üìÖ Upcoming events for next {days} days (not implemented)"
        except Exception as e:
            logger.error(f"Error getting upcoming events: {e}")
            return f"‚ùå Error getting upcoming events: {str(e)}"
    
    def reschedule_event(self, event_id: int, new_date: str, new_time: str = "") -> bool:
        """–ü–µ—Ä–µ–Ω–æ—Å —Å–æ–±—ã—Ç–∏—è"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –ø–µ—Ä–µ–Ω–æ—Å —Å–æ–±—ã—Ç–∏–π
            logger.info(f"üìÖ Rescheduled event {event_id} to {new_date}")
            return True
        except Exception as e:
            logger.error(f"Error rescheduling event: {e}")
            return False
    
    def complete_event(self, event_id: int) -> bool:
        """–ó–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏—è"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ —Å–æ–±—ã—Ç–∏–π
            logger.info(f"‚úÖ Completed event {event_id}")
            return True
        except Exception as e:
            logger.error(f"Error completing event: {e}")
            return False
    
    def get_event_statistics(self) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å–æ–±—ã—Ç–∏–π"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫—É —Å–æ–±—ã—Ç–∏–π
            return "üìä Event statistics (not implemented)"
        except Exception as e:
            logger.error(f"Error getting event statistics: {e}")
            return f"‚ùå Error getting event statistics: {str(e)}"
    
    def create_task_list(self, title: str, tasks: str) -> bool:
        """–°–æ–∑–¥–∞–Ω–∏–µ —Å–ø–∏—Å–∫–∞ –∑–∞–¥–∞—á"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–æ–∑–¥–∞–Ω–∏–µ —Å–ø–∏—Å–∫–æ–≤ –∑–∞–¥–∞—á
            logger.info(f"üìã Created task list: {title}")
            return True
        except Exception as e:
            logger.error(f"Error creating task list: {e}")
            return False
    
    def list_tasks(self, context: str = "") -> str:
        """–°–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Å–ø–∏—Å–æ–∫ –∑–∞–¥–∞—á
            return f"üìã Task list for context: {context} (not implemented)"
        except Exception as e:
            logger.error(f"Error listing tasks: {e}")
            return f"‚ùå Error listing tasks: {str(e)}"
    
    # –¢–µ—Ä–º–∏–Ω–∞–ª –∏ —Å–∏—Å—Ç–µ–º–∞
    def run_terminal_command(self, command: str) -> str:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –∫–æ–º–∞–Ω–¥—ã —Ç–µ—Ä–º–∏–Ω–∞–ª–∞"""
        try:
            # –ë–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å: –ø—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–º–∞–Ω–¥—É
            dangerous_commands = ['rm -rf', 'sudo', 'chmod 777', 'format', 'dd']
            if any(dangerous in command.lower() for dangerous in dangerous_commands):
                return "‚ùå Command blocked for security reasons"
            
            result = subprocess.run(command, shell=True, capture_output=True, text=True, timeout=30)
            
            if result.returncode == 0:
                return f"‚úÖ Command executed successfully:\n{result.stdout}"
            else:
                return f"‚ùå Command failed:\n{result.stderr}"
            
        except subprocess.TimeoutExpired:
            return "‚ùå Command timed out"
        except Exception as e:
            logger.error(f"Error running terminal command: {e}")
            return f"‚ùå Error running command: {str(e)}"
    
    def get_system_info(self) -> str:
        """–ü–æ–ª—É—á–µ–Ω–∏–µ –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–∏ –æ —Å–∏—Å—Ç–µ–º–µ"""
        try:
            import platform
            
            info = []
            info.append("üñ•Ô∏è System Information:")
            info.append(f"OS: {platform.system()} {platform.release()}")
            info.append(f"Architecture: {platform.machine()}")
            info.append(f"Python: {platform.python_version()}")
            info.append(f"Processor: {platform.processor()}")
            
            # –ò–Ω—Ñ–æ—Ä–º–∞—Ü–∏—è –æ –ø–∞–º—è—Ç–∏
            try:
                import psutil
                memory = psutil.virtual_memory()
                info.append(f"Memory: {memory.available // (1024**3)}GB available / {memory.total // (1024**3)}GB total")
            except ImportError:
                info.append("Memory: psutil not available")
            
            return "\n".join(info)
            
        except Exception as e:
            logger.error(f"Error getting system info: {e}")
            return f"‚ùå Error getting system info: {str(e)}"
    
    def diagnose_network(self) -> str:
        """–î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ —Å–µ—Ç–∏"""
        try:
            # TODO: –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏–∫—É —Å–µ—Ç–∏
            return "üåê Network diagnostics (not implemented)"
        except Exception as e:
            logger.error(f"Error diagnosing network: {e}")
            return f"‚ùå Error diagnosing network: {str(e)}"
    
    # –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    def _extract_tool_calls(self, text: str) -> List[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –≤—ã–∑–æ–≤–æ–≤ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∏–∑ —Ç–µ–∫—Å—Ç–∞"""
        try:
            # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –ø–æ–∏—Å–∫–∞ –≤—ã–∑–æ–≤–æ–≤ —Ñ—É–Ω–∫—Ü–∏–π
            pattern = r'(\w+)\s*\([^)]*\)'
            matches = re.findall(pattern, text)
            
            # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã –∏ —Å–æ—Ä—Ç–∏—Ä—É–µ–º
            unique_calls = list(set(matches))
            unique_calls.sort()
            
            return unique_calls
            
        except Exception as e:
            logger.error(f"Error extracting tool calls: {e}")
            return []
    
    def _extract_nested_calls(self, text: str) -> List[str]:
        """–ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤"""
        try:
            # –ë–æ–ª–µ–µ —Å–ª–æ–∂–Ω—ã–π –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –≤–ª–æ–∂–µ–Ω–Ω—ã—Ö –≤—ã–∑–æ–≤–æ–≤
            pattern = r'(\w+)\s*\([^)]*\)'
            matches = re.findall(pattern, text)
            
            # –£–±–∏—Ä–∞–µ–º –¥—É–±–ª–∏–∫–∞—Ç—ã
            unique_calls = list(set(matches))
            
            return unique_calls
            
        except Exception as e:
            logger.error(f"Error extracting nested calls: {e}")
            return []
    
    def _parse_arguments(self, args_str: str, expected_params: List[str]) -> Dict[str, Any]:
        """–£–Ω–∏–≤–µ—Ä—Å–∞–ª—å–Ω—ã–π –ø–∞—Ä—Å–µ—Ä –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤"""
        result = {}
        args_str = args_str.strip()
        
        # –ï—Å–ª–∏ –∞—Ä–≥—É–º–µ–Ω—Ç—ã –ø—É—Å—Ç—ã–µ, –≤–æ–∑–≤—Ä–∞—â–∞–µ–º –ø—É—Å—Ç–æ–π —Å–ª–æ–≤–∞—Ä—å
        if not args_str:
            return result
        
        # –ü—ã—Ç–∞–µ–º—Å—è –ø–∞—Ä—Å–∏—Ç—å –∫–∞–∫ –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã: param=value
        if '=' in args_str:
            # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –∏–º–µ–Ω–æ–≤–∞–Ω–Ω—ã—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤: param="value" –∏–ª–∏ param=value
            named_pattern = r'(\w+)\s*=\s*(?:"([^"]*)"|\'([^\']*)\'|(\w+))'
            named_matches = re.findall(named_pattern, args_str)
            
            for match in named_matches:
                param_name = match[0]
                param_value = next((val for val in match[1:] if val), "")
                result[param_name] = param_value
        
        # –ü—ã—Ç–∞–µ–º—Å—è –ø–∞—Ä—Å–∏—Ç—å –∫–∞–∫ –ø–æ–∑–∏—Ü–∏–æ–Ω–Ω—ã–µ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
        else:
            # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è —Å—Ç—Ä–æ–∫–æ–≤—ã—Ö –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –≤ –∫–∞–≤—ã—á–∫–∞—Ö
            quoted_pattern = r'["\']([^"\']*)["\']'
            quoted_matches = re.findall(quoted_pattern, args_str)
            
            # –ü–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –∞—Ä–≥—É–º–µ–Ω—Ç–æ–≤ –±–µ–∑ –∫–∞–≤—ã—á–µ–∫
            unquoted_pattern = r'\b(\w+)\b'
            unquoted_matches = re.findall(unquoted_pattern, args_str)
            
            # –û–±—ä–µ–¥–∏–Ω—è–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç—ã
            all_matches = quoted_matches + unquoted_matches
            
            # –°–æ–ø–æ—Å—Ç–∞–≤–ª—è–µ–º —Å –æ–∂–∏–¥–∞–µ–º—ã–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏
            for i, param in enumerate(expected_params):
                if i < len(all_matches):
                    result[param] = all_matches[i]
        
        return result
    
    def _execute_tool_call(self, tool_call: str) -> str:
        """–í—ã–ø–æ–ª–Ω–µ–Ω–∏–µ –≤—ã–∑–æ–≤–∞ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞"""
        try:
            # –ò–∑–≤–ª–µ–∫–∞–µ–º –∏–º—è —Ñ—É–Ω–∫—Ü–∏–∏ –∏ –∞—Ä–≥—É–º–µ–Ω—Ç—ã
            match = re.match(r'(\w+)\s*\((.*)\)', tool_call)
            if not match:
                return f"‚ùå Invalid tool call format: {tool_call}"
            
            func_name = match.group(1)
            args_str = match.group(2)
            
            # –í—ã–ø–æ–ª–Ω—è–µ–º —Å–æ–æ—Ç–≤–µ—Ç—Å—Ç–≤—É—é—â–∏–π –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç
            if func_name == "read_file":
                args = self._parse_arguments(args_str, ["path"])
                path = args.get("path", "config.py")
                logger.info(f"üîß read_file: path={path}")
                # –î–µ–ª–µ–≥–∏—Ä—É–µ–º –≤ FileTools
                from ..tools.file_tools import FileTools
                file_tools = FileTools()
                result = file_tools.read_file(path)
                logger.info(f"‚úÖ read_file result: {result[:200]}..." if len(result) > 200 else result)
                return result
            
            elif func_name == "list_files":
                args = self._parse_arguments(args_str, ["directory"])
                directory = args.get("directory", "")
                logger.info(f"üîß list_files: directory={directory}")
                # –î–µ–ª–µ–≥–∏—Ä—É–µ–º –≤ FileTools
                from ..tools.file_tools import FileTools
                file_tools = FileTools()
                result = file_tools.list_files(directory)
                logger.info(f"‚úÖ list_files result: {result}")
                return result
            
            elif func_name == "search_files":
                args = self._parse_arguments(args_str, ["query"])
                query = args.get("query", "system")
                logger.info(f"üîß search_files: query={query}")
                # –î–µ–ª–µ–≥–∏—Ä—É–µ–º –≤ FileTools
                from ..tools.file_tools import FileTools
                file_tools = FileTools()
                result = file_tools.search_files(query)
                logger.info(f"‚úÖ search_files result: {result}")
                return result
            
            elif func_name == "add_model_note":
                args = self._parse_arguments(args_str, ["note_text", "category"])
                note_text = args.get("note_text", "System note")
                category = args.get("category", "general")
                logger.info(f"üîß add_model_note: note_text={note_text[:50]}..., category={category}")
                # –î–µ–ª–µ–≥–∏—Ä—É–µ–º –≤ MemoryTools
                from ..tools.memory_tools import MemoryTools
                memory_tools = MemoryTools()
                result = memory_tools.add_model_note(note_text, category)
                logger.info(f"‚úÖ add_model_note result: {result}")
                return f"Added model note: {note_text[:50]}..."
            
            else:
                logger.error(f"‚ùå Unknown tool: {func_name}")
                return f"‚ùå Unknown tool: {func_name}"
            
        except Exception as e:
            logger.error(f"Error executing tool call {tool_call}: {e}")
            return f"‚ùå Error executing tool call: {str(e)}" 